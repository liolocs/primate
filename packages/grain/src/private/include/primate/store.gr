module Store

from "runtime/unsafe/conv" include Conv
from "bytes" include Bytes
from "buffer" include Buffer
from "uint32" include Uint32
from "./external.gr" include External
from "string" include String
from "json" include Json
from "result" include Result
from "./common.gr" include Common

use Conv.{ fromUint32, toUint32 }
use Json.{ type Json }

provide foreign wasm storeCount:
  (WasmI32) => WasmI32 from "primate"

provide foreign wasm storeDelete:
  (WasmI32) => WasmI32 from "primate"

provide foreign wasm storeGet:
  (WasmI32) => WasmI32 from "primate"

provide foreign wasm storeHas:
  (WasmI32) => WasmI32 from "primate"

provide foreign wasm storeImport:
  () => WasmI32 from "primate"

provide foreign wasm storeInsert:
  (WasmI32) => WasmI32 from "primate"

provide foreign wasm storeUpdate:
  (WasmI32) => WasmI32 from "primate"

provide foreign wasm storeFind:
  (WasmI32) => WasmI32 from "primate"

provide foreign wasm storeClear:
  (WasmI32) => WasmI32 from "primate"

provide type Store = Uint32
provide let _STORE_OPERATION_SUCCESS = 0ul
provide let _STORE_NOT_FOUND_ERROR = 1ul
provide let _STORE_RECORD_NOT_FOUND_ERROR = 2ul
provide let _STORE_UNKNOWN_ERROR_OCCURRED = 3ul
provide let _STORE_SCHEMA_INVALID_RECORD_ERROR = 4ul
provide let _STORE_OPERATION_NOT_SUPPORTED = 5ul

provide enum StoreErrorKind {
    StoreNotFound,
    RecordNotFound,
    UnknownError,
    SchemaInvalidRecordError,
    OperationNotSupported,
}

@unsafe
provide let count = (store: Store, criteria: Json = JsonNull) => {
    let store = fromUint32(store)
    let criteria = Result.expect("Criteria must be valid json", Json.toString(criteria))
    let byteLength = String.byteLength(criteria)
    let buffer = Buffer.make(4 + byteLength)
    Buffer.addUint32(Uint32.fromNumber(byteLength), buffer)
    Buffer.addString(criteria, buffer)
    let payload = Buffer.toBytes(buffer)
    External.sendBytes(payload)

    let result = toUint32(storeCount(store))
    if (result == _STORE_OPERATION_NOT_SUPPORTED) Err(OperationNotSupported)
    else if (result == _STORE_NOT_FOUND_ERROR) Err(StoreNotFound)
    else if (result == _STORE_OPERATION_SUCCESS) {
        let bytes = External.receiveBytes()
        let count = Bytes.getUint32(0, bytes)
        Ok(Uint32.toNumber(count))
    } else Err(UnknownError)
}

@unsafe
provide let delete = (store: Store, criteria: Json) => {
    let store = fromUint32(store)
    let criteria = Result.expect("Criteria must be valid json", Json.toString(criteria))
    let criteriaLength = String.byteLength(criteria)
    let buffer = Buffer.make(criteriaLength + 4)
    Buffer.addUint32(Uint32.fromNumber(criteriaLength), buffer)
    Buffer.addString(criteria, buffer)
    let payload = Buffer.toBytes(buffer)
    External.sendBytes(payload)
    let result = toUint32(storeDelete(store))
    if (result == _STORE_NOT_FOUND_ERROR) Err(StoreNotFound)
    else if (result == _STORE_RECORD_NOT_FOUND_ERROR) Err(RecordNotFound)
    else if (result == _STORE_OPERATION_SUCCESS) Ok(void)
    else Err(UnknownError)
}

provide let deleteById = (store: Store, id: String) => delete(store, JsonString(id))

@unsafe
provide let store = (path: String) => {
    let pathLength = String.byteLength(path)
    let buffer = Buffer.make(pathLength + 4)
    Buffer.addUint32(Uint32.fromNumber(pathLength), buffer)
    Buffer.addString(path, buffer)
    let payload = Buffer.toBytes(buffer)
    External.sendBytes(payload)
    
    let result = Conv.toUint32(storeImport())
    if (result == _STORE_NOT_FOUND_ERROR) Err(StoreNotFound)
    else if (result == _STORE_OPERATION_SUCCESS) {
        let bytes = External.receiveBytes()
        Ok(Bytes.getUint32(0, bytes))
    }
    else Err(UnknownError)
}

@unsafe
provide let get = (store: Store, id: String) => {
    let store = fromUint32(store)
    let idLength = String.byteLength(id)
    let buffer = Buffer.make(idLength + 4)
    Buffer.addUint32(Uint32.fromNumber(idLength), buffer)
    Buffer.addString(id, buffer)
    let payload = Buffer.toBytes(buffer)
    External.sendBytes(payload)

    let result = Conv.toUint32(storeGet(store))

    if (result == _STORE_NOT_FOUND_ERROR) Err(StoreNotFound)
    else if (result == _STORE_RECORD_NOT_FOUND_ERROR) Err(RecordNotFound)
    else if (result == _STORE_OPERATION_SUCCESS) {
        let bytes = External.receiveBytes()
        let (_, json) = Common.readJson(0, bytes)
        Ok(json)
    }
    else Err(UnknownError)
}

@unsafe
provide let has = (store: Store, id: String) => {
    let store = fromUint32(store)
    let idLength = String.byteLength(id)
    let buffer = Buffer.make(idLength + 4)
    Buffer.addUint32(Uint32.fromNumber(idLength), buffer)
    Buffer.addString(id, buffer)
    let bytes = Buffer.toBytes(buffer)
    External.sendBytes(bytes)

    let result = Conv.toUint32(storeHas(store))
    if (result == _STORE_NOT_FOUND_ERROR) Err(StoreNotFound)
    else if (result == _STORE_OPERATION_SUCCESS) {
        let bytes = External.receiveBytes()
        let hasResult = Bytes.getUint32(0, bytes)
        Ok(hasResult == 1ul)
    }
    else Err(UnknownError)
}

@unsafe
provide let find = (store: Store, criteria: Json) => {
    let store = fromUint32(store)
    let criteria = Result.expect(
        "Criteria must be valid json",
        Json.toString(criteria),
    )
    let criteriaLength = String.byteLength(criteria)
    let buffer = Buffer.make(criteriaLength + 4)
    Buffer.addUint32(Uint32.fromNumber(criteriaLength), buffer)
    Buffer.addString(criteria, buffer)
    let bytes = Buffer.toBytes(buffer)
    External.sendBytes(bytes)

    let result = Conv.toUint32(storeFind(store))
    if (result == _STORE_NOT_FOUND_ERROR) Err(StoreNotFound)
    else if (result == _STORE_OPERATION_SUCCESS) {
        let bytes = External.receiveBytes()
        let (_, json) =  Common.readJson(0, bytes)
        Ok(json)
    } else Err(UnknownError)
}

@unsafe
provide let insert = (store: Store, value: Json) => {
    let store = fromUint32(store)
    let value = Result.expect("Value must be valid json", Json.toString(value))
    let valueLength = String.byteLength(value)
    let buffer = Buffer.make(valueLength + 4)
    Buffer.addUint32(Uint32.fromNumber(valueLength), buffer)
    Buffer.addString(value, buffer)
    let bytes = Buffer.toBytes(buffer)
    External.sendBytes(bytes)

    let result = Conv.toUint32(storeInsert(store))
    if (result == _STORE_NOT_FOUND_ERROR) Err(StoreNotFound)
    else if (result == _STORE_SCHEMA_INVALID_RECORD_ERROR) Err(SchemaInvalidRecordError)
    else if (result == _STORE_OPERATION_SUCCESS) {
      let bytes = External.receiveBytes()
      let (_, json) = Common.readJson(0, bytes)
      Ok(json)
    }
    else Err(UnknownError)
}

@unsafe
provide let update = (store: Store, id: String, value: Json) => {
    let store = fromUint32(store)
    let value = Result.expect("Value must be valid json", Json.toString(value))
    let idLength = String.byteLength(id)
    let valueLength = String.byteLength(value)
    let buffer = Buffer.make(idLength + 4 + valueLength + 4)
    Buffer.addUint32(Uint32.fromNumber(idLength), buffer)
    Buffer.addString(id, buffer)
    Buffer.addUint32(Uint32.fromNumber(valueLength), buffer)
    Buffer.addString(value, buffer)
    let bytes = Buffer.toBytes(buffer)
    External.sendBytes(bytes)

    let result = Conv.toUint32(storeUpdate(store))
    if (result == _STORE_NOT_FOUND_ERROR) Err(StoreNotFound)
    else if (result == _STORE_SCHEMA_INVALID_RECORD_ERROR) Err(SchemaInvalidRecordError)
    else if (result == _STORE_OPERATION_SUCCESS) Ok(void)
    else Err(UnknownError)
}

@unsafe
provide let clear = (store: Store) => {
  let store = fromUint32(store)
  let result = Conv.toUint32(storeClear(store))
  if (result == _STORE_NOT_FOUND_ERROR) Err(StoreNotFound)
  else if (result == _STORE_OPERATION_SUCCESS) Ok(void)
  else Err(UnknownError)
}

